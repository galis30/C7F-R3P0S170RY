Úloha 2

EN: It turns out Bob wasn’t lucky after all. This tool isn’t a helpful diagnostic. Can you reveal its true purpose?

SK: Ukázalo sa, že na Boba sa veľké štastie neusmialo. Tento nástroj nie je práve najvhodnejší na diagnostiku. Vieš odhaliť jeho skutočný účel?


Riešenie:

Zameral som sa na časť kodu:

Socket socket = new Socket(serverIp, serverPort);
PrintWriter output = new PrintWriter(socket.getOutputStream(), true);
BufferedReader input = new BufferedReader((Reader)(new InputStreamReader(socket.getInputStream())));
	byte[] var13 = new byte[]{-67, -33, 90, 3, -3, -61, -71, 35, 109, 78, 37, -109, 113, 90, 	65, -109, -99, 66, 90, 66, 65, 83, 66, 79, 53};
               byte[] s = var13;
               int m = 0;

               for(int var14 = var13.length; m < var14; ++m) {
                  int c = s[m] & 255;
                  c ^= m;
                  c = c - 10 & 255;
                  c = -c & 255;
                  c = c + m & 255;
                  c = (c >> 2 | c << 6) & 255;
                  s[m] = (byte)c;
               } 

Pole byte[] obsahuje bajty, ktoré treba krok po kroku (for cyklus) transformovať.
Použil som python kód:

# Pôvodné bajty (rovnaké ako v Java kóde)
var13 = [
    -67, -33, 90, 3, -3, -61, -71, 35, 109, 78, 37, -109, 113, 90,
    65, -109, -99, 66, 90, 66, 65, 83, 66, 79, 53
]

# Konverzia na unsigned bajty (ako v Java: byte & 0xFF)
s = [(b + 256) % 256 for b in var13]

# Aplikácia transformácie (rovnaké operácie ako v Jave)
for m in range(len(s)):
    c = s[m]
    c ^= m
    c = (c - 10) % 256
    c = (-c) % 256
    c = (c + m) % 256
    c = ((c >> 2) | (c << 6)) & 0xFF  # rotácia doprava o 2 bity
    s[m] = c

# Prevod na ASCII reťazec
decoded = ''.join(chr(b) for b in s)
print(f"Decoded flag: {decoded}")

Výsledok je vlajka flag{pr0xy_c0nfig_m4gic}.
